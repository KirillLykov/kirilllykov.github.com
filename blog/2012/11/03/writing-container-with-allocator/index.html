
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Writing container with allocator - K. Lykov Blog</title>
  <meta name="author" content="Kirill Lykov">

  
  <meta name="description" content="In this post I will write how to implement container using allocators. As an example of container to be developed I picked up
2D array of elements. &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://KirillLykov.github.com/blog/2012/11/03/writing-container-with-allocator/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/ender.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/atom.xml" rel="alternate" title="K. Lykov Blog" type="application/atom+xml">
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">K. Lykov Blog</a></h1>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:KirillLykov.github.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/blog/about">About</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">Writing Container With Allocator</h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-11-03T19:08:00+01:00" pubdate data-updated="true">Nov 3<span>rd</span>, 2012</time>
        
      </p>
    
  </header>


<div class="entry-content"><p>In this post I will write how to implement container using allocators. As an example of container to be developed I picked up
2D array of elements.</p>

<!-- more -->


<h2>Tests for container</h2>


<p>I firmly believe that tests should be developed before writing any code, especially general-purpose library code.
Lets call our container grid2D. It will be template class which has two template parameters - data type and allocator type.
By default allocator type will be std::allocator.
I&#8217;ve chousen google c++ test framework. It is pretty easy to use. First, download it, then build it using make or cmake.
Cmake is preferable, but it can also be build in old-fashion maner:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>./configure
</span><span class='line'>make</span></code></pre></td></tr></table></div></figure>


<p>Built libraries can be found in  ${GTEST_ROOT}/lib/.lib. Show them to your linker and add to include directories ${GTEST_ROOT|/include.
If linker says that it can&#8217;t find gtest library (it may try to find them somewhere in a system directory), copy it to the place where
linker is looking it.
All test functions should be declared using TEST macros. The syntax is simple: TEST(<test_group_name>, &lt;test_name>) { &#8230; }
Google test frameworks employes several macroses to check test&#39;s conditions. The most useful is EXPECT_EQ(arg1, arg2) which
expects equaty of arg1 and arg2. If the condition is not sutisfied, it will not terminate the process.
Test functions might be called from main function.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;gtest/gtest.h&gt;
</span><span class='line'>
</span><span class='line'>TEST(TwoDGridTest, construction)
</span><span class='line'>{
</span><span class='line'>    grid2D&lt;double&gt; grid(1, 2);
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>TEST(TwoDGridTest, copyConstruction)
</span><span class='line'>{
</span><span class='line'>    grid2D&lt;double&gt; grid1(1, 2);
</span><span class='line'>    grid2D&lt;double&gt; grid2(grid1);
</span><span class='line'>    EXPECT_EQ(grid1, grid2);
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>TEST(TwoDGridTest, assignment)
</span><span class='line'>{
</span><span class='line'>    grid2D&lt;double&gt; grid1(1, 2);
</span><span class='line'>    grid2D&lt;double&gt; grid2(1, 2);
</span><span class='line'>    grid2 = grid1;
</span><span class='line'>    EXPECT_EQ(grid1, grid2);
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>// grid with differnt sizes must not be assigned
</span><span class='line'>TEST(TwoDGridTest, assignmentBrake)
</span><span class='line'>{
</span><span class='line'>  grid2D&lt;double&gt; grid1(1, 2);
</span><span class='line'>  grid2D&lt;double&gt; grid2(2, 3);
</span><span class='line'>  try {
</span><span class='line'>    grid2 = grid1;
</span><span class='line'>  }
</span><span class='line'>  catch (const AllocationUtils::array_size_error& er)
</span><span class='line'>  {
</span><span class='line'>    return;
</span><span class='line'>  }
</span><span class='line'>  EXPECT_TRUE(false);
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>TEST(TwoDGridTest, access)
</span><span class='line'>{
</span><span class='line'>  size_t n = 2, m = 4;
</span><span class='line'>  grid2D&lt;double&gt; grid(n, m);
</span><span class='line'>  for (size_t i = 0; i &lt; n; ++i) {
</span><span class='line'>    for (size_t j = 0; j &lt; m; ++j) {
</span><span class='line'>      grid(i, j) = i * j;
</span><span class='line'>    }
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  const grid2D&lt;double&gt; grid2 = grid;
</span><span class='line'>  for (size_t i = 0; i &lt; n; ++i) {
</span><span class='line'>    for (size_t j = 0; j &lt; m; ++j) {
</span><span class='line'>      EXPECT_EQ(grid2(i, j), i * j);
</span><span class='line'>    }
</span><span class='line'>  }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>int main(int argc, char** argv)
</span><span class='line'>{
</span><span class='line'>  ::testing::InitGoogleTest(&argc, argv);
</span><span class='line'>  return RUN_ALL_TESTS();
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p>I hope test above are self-explanatory.</p>

<h2>Implementing container</h2>


<p>Why do we need to use allocator? Because allocation of elements in the container may be done in several ways.
The most common case in implemented in std::allocator but this implementation is not acceptable if your container is
used by several threads, processes or when you prefer to use your own memory manager. Examples of different allocators
implementation can be found in boost: boost::mpi::allocator, boost::interprocess::allocator, boost::detail::quick_allocator.</p>

<p>Grid class should have two templates parameters - type of objects to be stored and allocator type. I use
nested template for allocator because it gives additional flexibility in comparison with class allocator = std::allocator<T>.
Grid has sizes, pointer to the block of data, and allocator instance. Allocator is declared mutable because I want to use it in
const methods while allocators methods are not const.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  template&lt; class T, template&lt;typename X&gt; class allocator = std::allocator &gt;
</span><span class='line'>  class grid2D
</span><span class='line'>  {
</span><span class='line'>    size_t m_n1, m_n2;
</span><span class='line'>    mutable allocator&lt;T&gt; m_allocator;
</span><span class='line'>    size_t m_linearSz;
</span><span class='line'>    T* m_data;
</span><span class='line'>    
</span><span class='line'>    typedef grid2D&lt;T, allocator&gt; _TGrid;
</span><span class='line'>  public:
</span><span class='line'>    grid2D(size_t n1, size_t n2)
</span><span class='line'>       :  m_n1(n1), m_n2(n2), m_linearSz(n1 * n2), m_data(0)
</span><span class='line'>     {
</span><span class='line'>       m_data = m_allocator.allocate(m_linearSz);
</span><span class='line'>       std::uninitialized_fill_n(m_data, m_linearSz, T());
</span><span class='line'>     }
</span><span class='line'>
</span><span class='line'>    grid2D(const _TGridImpl& another)
</span><span class='line'>      : m_n1(another.m_n1), m_n2(another.m_n2), m_linearSz(another.m_linearSz)
</span><span class='line'>    {
</span><span class='line'>      m_data = m_allocator.allocate(m_linearSz);
</span><span class='line'>      std::uninitialized_copy(another.m_data, another.m_data + m_linearSz, this-&gt;m_data);
</span><span class='line'>    }</span></code></pre></td></tr></table></div></figure>


<p>In constructors, I allocate linear block of memory and then call functions with preffix uninitialized which means that they work with allocated but not initialized memory (constructos were not called).
It is important to underline that method allocator::allocate does not call constructors for the objects.
Call of std::uninitialized_fill_n will call constructors for the allocated blocks of memory. It is implemented like that:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  template&lt;typename _T1&gt;
</span><span class='line'>  inline void construct(_T1* p)
</span><span class='line'>  {
</span><span class='line'>    ::new(static_cast&lt;void*&gt;(p)) _T1;
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  template&lt;typename _ForwardIterator, typename _Size&gt;
</span><span class='line'>  void uninit_fill_n(_ForwardIterator first, _Size n)
</span><span class='line'>  {
</span><span class='line'>    _ForwardIterator cur = first;
</span><span class='line'>    try
</span><span class='line'>    {
</span><span class='line'>      for (; n &gt; 0; --n, ++cur)
</span><span class='line'>        construct(addressof(*cur));
</span><span class='line'>    }
</span><span class='line'>    catch (...)
</span><span class='line'>    {
</span><span class='line'>      destroy(first, cur);
</span><span class='line'>      throw;
</span><span class='line'>    }
</span><span class='line'>  }</span></code></pre></td></tr></table></div></figure>


<p>Similarly, algorithm std::uninitialized_copy calls copy-constructors without allocating memory for objects. So we see that allocator separates raw memory allocation and
calls of constructos. It was done for the sake of flexibility, efficiency and safity. //some explanations here</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>virtual ~grid_impl()
</span><span class='line'>{
</span><span class='line'>  destroy(m_data, m_data + m_linearSz);
</span><span class='line'>  m_allocator.deallocate(m_data, m_linearSz);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>The next crucial method is operator= in which I employ deep-copy approach - i.e just copy all object from the source grid into the target using std::copy:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>_TGrid& operator= (const _TGrid& another)
</span><span class='line'>{
</span><span class='line'>  if (this == &another)
</span><span class='line'>    return *this;
</span><span class='line'>
</span><span class='line'>  if (m_n1 != another.m_n1 || m_n2 != another.m_n2)
</span><span class='line'>    throw logical_error();
</span><span class='line'>
</span><span class='line'>  std::copy(another.m_data, another.m_data + m_linearSz, this-&gt;m_data);
</span><span class='line'>
</span><span class='line'>  return *this;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>Additionally, we may add operator== and operator!= which use std::equal algorithm:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>bool operator== (const _TGridImpl& another) const
</span><span class='line'>{
</span><span class='line'> return std::equal(m_data, m_data + m_linearSz, another.m_data);
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>bool operator!= (const _TGridImpl& another) const
</span><span class='line'>{
</span><span class='line'> return !this-&gt;operator== (another);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>Basicly destroy is implemeted this way in std::alocator:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  template&lt;typename T&gt;
</span><span class='line'>  inline void destroy(T* p) { p-&gt;~T(); }
</span><span class='line'>
</span><span class='line'>  template&lt;typename _ForwardIterator&gt;
</span><span class='line'>  void destroy(_ForwardIterator first, _ForwardIterator last)
</span><span class='line'>  {
</span><span class='line'>    for (; first != last; ++first)
</span><span class='line'>      destroy(addressof(*first));
</span><span class='line'>  }</span></code></pre></td></tr></table></div></figure>


<p>Finally, the most important operator is access to the elements. It can be implemented in form get(size_t i, size_t j)
but I prefer a bit more sugarish implementation with operator():</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>const T& operator() (size_t i, size_t j) const
</span><span class='line'>{
</span><span class='line'>  return _TGridImpl::m_data[i + m_n1 * j];
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>T& operator() (size_t i, size_t j)
</span><span class='line'>{
</span><span class='line'>  return _TGridImpl::m_data[i + m_n1 * j];
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>

</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">Kirill Lykov</span></span>

      








  


<time datetime="2012-11-03T19:08:00+01:00" pubdate data-updated="true">Nov 3<span>rd</span>, 2012</time>
      


    </p>
    
      <div class="sharing">
  
  <a href="http://twitter.com/share" class="twitter-share-button" data-url="http://KirillLykov.github.com/blog/2012/11/03/writing-container-with-allocator/" data-via="" data-counturl="http://KirillLykov.github.com/blog/2012/11/03/writing-container-with-allocator/" >Tweet</a>
  
  
  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2012/10/22/lammps-how-to-compute-fluid-viscosity/" title="Previous Post: LAMMPS: How to compute fluid viscosity">&laquo; LAMMPS: How to compute fluid viscosity</a>
      
      
    </p>
  </footer>
</article>

</div>

<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2012/11/03/writing-container-with-allocator/">Writing container with allocator</a>
      </li>
    
      <li class="post">
        <a href="/blog/2012/10/22/lammps-how-to-compute-fluid-viscosity/">LAMMPS: How to compute fluid viscosity</a>
      </li>
    
      <li class="post">
        <a href="/blog/2012/10/13/writing-fixes-for-lammps/">How to write fix for LAMMPS</a>
      </li>
    
      <li class="post">
        <a href="/blog/2012/10/12/initial-post/">Java Modeling Language</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating...</li>
  </ul>
  
  <a href="https://github.com/KirillLykov">@KirillLykov</a> on GitHub
  
  <script type="text/javascript">
    $.domReady(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'KirillLykov',
            count: 2,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>




<section class="googleplus googleplus-hidden">
  <h1>
    <a href="https://plus.google.com/Kirill Lykov?rel=author">
      <img src="http://www.google.com/images/icons/ui/gprofile_button-32.png" width="32" height="32">
      Google+
    </a>
  </h1>
</section>



  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2012 - Kirill Lykov -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
