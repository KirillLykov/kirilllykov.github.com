<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[K. Lykov Blog]]></title>
  <link href="http://KirillLykov.github.com/atom.xml" rel="self"/>
  <link href="http://KirillLykov.github.com/"/>
  <updated>2012-11-07T11:41:10+01:00</updated>
  <id>http://KirillLykov.github.com/</id>
  <author>
    <name><![CDATA[Kirill Lykov]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Writing container with allocator]]></title>
    <link href="http://KirillLykov.github.com/blog/2012/11/03/writing-container-with-allocator/"/>
    <updated>2012-11-03T19:08:00+01:00</updated>
    <id>http://KirillLykov.github.com/blog/2012/11/03/writing-container-with-allocator</id>
    <content type="html"><![CDATA[<p>In this post I will write how to implement container using allocators. As an example of container to be developed I picked up
2D array of elements.</p>

<!-- more -->


<h2>Tests for container</h2>


<p>I firmly believe that tests should be developed before writing any code, especially general-purpose library code.
Lets call our container grid2D. It will be template class which has two template parameters - data type and allocator type.
By default allocator type will be std::allocator.
I&#8217;ve chousen google c++ test framework. It is pretty easy to use. First, download it, then build it using make or cmake.
Cmake is preferable, but it can also be build in old-fashion maner:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>./configure
</span><span class='line'>make</span></code></pre></td></tr></table></div></figure>


<p>Built libraries can be found in  ${GTEST_ROOT}/lib/.lib. Show them to your linker and add to include directories ${GTEST_ROOT|/include.
If linker says that it can&#8217;t find gtest library (it may try to find them somewhere in a system directory), copy it to the place where
linker is looking it.
All test functions should be declared using TEST macros. The syntax is simple: TEST(<test_group_name>, &lt;test_name>) { &#8230; }
Google test frameworks employes several macroses to check test&#39;s conditions. The most useful is EXPECT_EQ(arg1, arg2) which
expects equaty of arg1 and arg2. If the condition is not sutisfied, it will not terminate the process.
Test functions might be called from main function.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;gtest/gtest.h&gt;
</span><span class='line'>
</span><span class='line'>TEST(TwoDGridTest, construction)
</span><span class='line'>{
</span><span class='line'>    grid2D&lt;double&gt; grid(1, 2);
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>TEST(TwoDGridTest, copyConstruction)
</span><span class='line'>{
</span><span class='line'>    grid2D&lt;double&gt; grid1(1, 2);
</span><span class='line'>    grid2D&lt;double&gt; grid2(grid1);
</span><span class='line'>    EXPECT_EQ(grid1, grid2);
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>TEST(TwoDGridTest, assignment)
</span><span class='line'>{
</span><span class='line'>    grid2D&lt;double&gt; grid1(1, 2);
</span><span class='line'>    grid2D&lt;double&gt; grid2(1, 2);
</span><span class='line'>    grid2 = grid1;
</span><span class='line'>    EXPECT_EQ(grid1, grid2);
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>// grid with differnt sizes must not be assigned
</span><span class='line'>TEST(TwoDGridTest, assignmentBrake)
</span><span class='line'>{
</span><span class='line'>  grid2D&lt;double&gt; grid1(1, 2);
</span><span class='line'>  grid2D&lt;double&gt; grid2(2, 3);
</span><span class='line'>  try {
</span><span class='line'>    grid2 = grid1;
</span><span class='line'>  }
</span><span class='line'>  catch (const AllocationUtils::array_size_error& er)
</span><span class='line'>  {
</span><span class='line'>    return;
</span><span class='line'>  }
</span><span class='line'>  EXPECT_TRUE(false);
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>TEST(TwoDGridTest, access)
</span><span class='line'>{
</span><span class='line'>  size_t n = 2, m = 4;
</span><span class='line'>  grid2D&lt;double&gt; grid(n, m);
</span><span class='line'>  for (size_t i = 0; i &lt; n; ++i) {
</span><span class='line'>    for (size_t j = 0; j &lt; m; ++j) {
</span><span class='line'>      grid(i, j) = i * j;
</span><span class='line'>    }
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  const grid2D&lt;double&gt; grid2 = grid;
</span><span class='line'>  for (size_t i = 0; i &lt; n; ++i) {
</span><span class='line'>    for (size_t j = 0; j &lt; m; ++j) {
</span><span class='line'>      EXPECT_EQ(grid2(i, j), i * j);
</span><span class='line'>    }
</span><span class='line'>  }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>int main(int argc, char** argv)
</span><span class='line'>{
</span><span class='line'>  ::testing::InitGoogleTest(&argc, argv);
</span><span class='line'>  return RUN_ALL_TESTS();
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p>I hope test above are self-explanatory.</p>

<h2>Implementing container</h2>


<p>Why do we need to use allocator? Because allocation of elements in the container may be done in several ways.
The most common case in implemented in std::allocator but this implementation is not acceptable if your container is
used by several threads, processes or when you prefer to use your own memory manager. Examples of different allocators
implementation can be found in boost: boost::mpi::allocator, boost::interprocess::allocator, boost::detail::quick_allocator.</p>

<p>Grid class should have two templates parameters - type of objects to be stored and allocator type. I use
nested template for allocator because it gives additional flexibility in comparison with class allocator = std::allocator<T>.
Grid has sizes, pointer to the block of data, and allocator instance. Allocator is declared mutable because I want to use it in
const methods while allocators methods are not const.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  template&lt; class T, template&lt;typename X&gt; class allocator = std::allocator &gt;
</span><span class='line'>  class grid2D
</span><span class='line'>  {
</span><span class='line'>    size_t m_n1, m_n2;
</span><span class='line'>    mutable allocator&lt;T&gt; m_allocator;
</span><span class='line'>    size_t m_linearSz;
</span><span class='line'>    T* m_data;
</span><span class='line'>    
</span><span class='line'>    typedef grid2D&lt;T, allocator&gt; _TGrid;
</span><span class='line'>  public:
</span><span class='line'>    grid2D(size_t n1, size_t n2)
</span><span class='line'>       :  m_n1(n1), m_n2(n2), m_linearSz(n1 * n2), m_data(0)
</span><span class='line'>     {
</span><span class='line'>       m_data = m_allocator.allocate(m_linearSz);
</span><span class='line'>       std::uninitialized_fill_n(m_data, m_linearSz, T());
</span><span class='line'>     }
</span><span class='line'>
</span><span class='line'>    grid2D(const _TGridImpl& another)
</span><span class='line'>      : m_n1(another.m_n1), m_n2(another.m_n2), m_linearSz(another.m_linearSz)
</span><span class='line'>    {
</span><span class='line'>      m_data = m_allocator.allocate(m_linearSz);
</span><span class='line'>      std::uninitialized_copy(another.m_data, another.m_data + m_linearSz, this-&gt;m_data);
</span><span class='line'>    }</span></code></pre></td></tr></table></div></figure>


<p>In constructors, I allocate linear block of memory and then call functions with preffix uninitialized which means that they work with allocated but not initialized memory (constructos were not called).
It is important to underline that method allocator::allocate does not call constructors for the objects.
Call of std::uninitialized_fill_n will call constructors for the allocated blocks of memory. It is implemented like that:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  template&lt;typename _T1&gt;
</span><span class='line'>  inline void construct(_T1* p)
</span><span class='line'>  {
</span><span class='line'>    ::new(static_cast&lt;void*&gt;(p)) _T1;
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  template&lt;typename _ForwardIterator, typename _Size&gt;
</span><span class='line'>  void uninit_fill_n(_ForwardIterator first, _Size n)
</span><span class='line'>  {
</span><span class='line'>    _ForwardIterator cur = first;
</span><span class='line'>    try
</span><span class='line'>    {
</span><span class='line'>      for (; n &gt; 0; --n, ++cur)
</span><span class='line'>        construct(addressof(*cur));
</span><span class='line'>    }
</span><span class='line'>    catch (...)
</span><span class='line'>    {
</span><span class='line'>      destroy(first, cur);
</span><span class='line'>      throw;
</span><span class='line'>    }
</span><span class='line'>  }</span></code></pre></td></tr></table></div></figure>


<p>Similarly, algorithm std::uninitialized_copy calls copy-constructors without allocating memory for objects. So we see that allocator separates raw memory allocation and
calls of constructos. It was done for the sake of flexibility, efficiency and safity. //some explanations here</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>virtual ~grid_impl()
</span><span class='line'>{
</span><span class='line'>  destroy(m_data, m_data + m_linearSz);
</span><span class='line'>  m_allocator.deallocate(m_data, m_linearSz);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>The next crucial method is operator= in which I employ deep-copy approach - i.e just copy all object from the source grid into the target using std::copy:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>_TGrid& operator= (const _TGrid& another)
</span><span class='line'>{
</span><span class='line'>  if (this == &another)
</span><span class='line'>    return *this;
</span><span class='line'>
</span><span class='line'>  if (m_n1 != another.m_n1 || m_n2 != another.m_n2)
</span><span class='line'>    throw logical_error();
</span><span class='line'>
</span><span class='line'>  std::copy(another.m_data, another.m_data + m_linearSz, this-&gt;m_data);
</span><span class='line'>
</span><span class='line'>  return *this;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>Additionally, we may add operator== and operator!= which use std::equal algorithm:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>bool operator== (const _TGridImpl& another) const
</span><span class='line'>{
</span><span class='line'> return std::equal(m_data, m_data + m_linearSz, another.m_data);
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>bool operator!= (const _TGridImpl& another) const
</span><span class='line'>{
</span><span class='line'> return !this-&gt;operator== (another);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>Basicly destroy is implemeted this way in std::alocator:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  template&lt;typename T&gt;
</span><span class='line'>  inline void destroy(T* p) { p-&gt;~T(); }
</span><span class='line'>
</span><span class='line'>  template&lt;typename _ForwardIterator&gt;
</span><span class='line'>  void destroy(_ForwardIterator first, _ForwardIterator last)
</span><span class='line'>  {
</span><span class='line'>    for (; first != last; ++first)
</span><span class='line'>      destroy(addressof(*first));
</span><span class='line'>  }</span></code></pre></td></tr></table></div></figure>


<p>Finally, the most important operator is access to the elements. It can be implemented in form get(size_t i, size_t j)
but I prefer a bit more sugarish implementation with operator():</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>const T& operator() (size_t i, size_t j) const
</span><span class='line'>{
</span><span class='line'>  return _TGridImpl::m_data[i + m_n1 * j];
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>T& operator() (size_t i, size_t j)
</span><span class='line'>{
</span><span class='line'>  return _TGridImpl::m_data[i + m_n1 * j];
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[LAMMPS: How to compute fluid viscosity]]></title>
    <link href="http://KirillLykov.github.com/blog/2012/10/22/lammps-how-to-compute-fluid-viscosity/"/>
    <updated>2012-10-22T14:47:00+02:00</updated>
    <id>http://KirillLykov.github.com/blog/2012/10/22/lammps-how-to-compute-fluid-viscosity</id>
    <content type="html"><![CDATA[<p>The theory is described in “Poiseuille flow to measure the viscosity of particle model fluids” by J. A. Backer et al. Below
I describe how to use this approach in LAMMPS.</p>

<!--more-->


<p>(1) Run LAMMPS with the following script</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>boundary p p p
</span><span class='line'>
</span><span class='line'>units     lj
</span><span class='line'>atom_style    atomic
</span><span class='line'>
</span><span class='line'>lattice custom 3.0 a1 1.0 0.0 0.0 a2 0.0 1.0 0.0 a3 0.0 0.0 1.0 &
</span><span class='line'>      basis 0.5 0.0 0.0 basis 0.0 0.5 0.0 basis 0.0 0.0 0.5
</span><span class='line'>
</span><span class='line'>region box block -7.0 7.0  -7.0 7.0  -14.0 14.0
</span><span class='line'>
</span><span class='line'>region left  block -7.0 7.0  -7.0 7.0 -14.0 0.0
</span><span class='line'>region right block -7.0 7.0  -7.0 7.0 0.0 14.0
</span><span class='line'>
</span><span class='line'># Uncomment it if you don't use restart file
</span><span class='line'>create_box  1 box
</span><span class='line'>create_atoms    1 box
</span><span class='line'>mass        1 1.0
</span><span class='line'>
</span><span class='line'>neighbor    0.3 bin
</span><span class='line'>neigh_modify    delay 0 every 4 check no
</span><span class='line'>
</span><span class='line'>#******************DPD******************
</span><span class='line'>#to store velocities by ghost atoms
</span><span class='line'>communicate single vel yes
</span><span class='line'># T cutoff seed
</span><span class='line'>pair_style  dpd 0.1 1.0 34387
</span><span class='line'># atom_type atom_type a gamma=sigma^2/2 cutoff(optional)
</span><span class='line'># where a is Fc coefficent.
</span><span class='line'>pair_coeff  1 1 25.0 45.0 1.0
</span><span class='line'>
</span><span class='line'>thermo          500
</span><span class='line'>timestep 0.01
</span><span class='line'>
</span><span class='line'>fix 1 all nve
</span><span class='line'>fix 2 all addforce -0.055 0.0 0.0 region left
</span><span class='line'>fix 3 all addforce 0.055 0.0 0.0 region right
</span><span class='line'>fix 4 all ave/spatial 50 1000 50000 z center 0.5 vx file vel-visc.txt
</span><span class='line'>
</span><span class='line'>run 100000</span></code></pre></td></tr></table></div></figure>


<p>(2) Open vel-visc and copy in a separate document data for one time step.</p>

<p>(3) Open gnuplot, type:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>gnuplot&gt; plot "visc_vel.txt" using 2:4</span></code></pre></td></tr></table></div></figure>


<p>The result should be something like:
<img src="../../../../../images/velprofile1.png" width="400"></p>

<p>(4) From analytical solution for the problem, it is known that v(x)=alpha*(x*D - x*x). Where alpha=p*g/(2*n), p - is numeric density(3.0 in our case,
determined by custom lattice), g is driving force (0.055), n - dynamic viscosity.
In order to find alpha we will use gnuplot’s fit command. As you might  see on the Figure above, there are 2 parabolas. I pick the left one, so the analytical solution look like v(x)=alpha<em>(x</em>14 + x*x). Then type</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>gnuplot&gt; f(x)=a*(x*14 + x*x)
</span><span class='line'>gnuplot&gt; fit f(x) 'visc_vel.txt' using 2:4 via a
</span><span class='line'>gnuplot&gt; plot "visc_vel.txt" using 2:4, f(x)</span></code></pre></td></tr></table></div></figure>


<p>The result should be a=0.0278, thus n=2.68. The plot with velocities from simulation and  with the fitting plot should look like that:
<img src="../../../../../images/velprofile2.png" width="400"></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to write fix for LAMMPS]]></title>
    <link href="http://KirillLykov.github.com/blog/2012/10/13/writing-fixes-for-lammps/"/>
    <updated>2012-10-13T21:08:00+02:00</updated>
    <id>http://KirillLykov.github.com/blog/2012/10/13/writing-fixes-for-lammps</id>
    <content type="html"><![CDATA[<p>Writing fixes is the main way of extending LAMMPS.  User can implement many things using fixes, including (but not limited):<br>
·      changing particles characteristics (positions, velocities, forces, etc.). Example: fix_freeze.<br>
·      reading/writing data. Example: fix_restart.<br>
·      implementing boundary conditions. Example: fix_wall*.<br>
·      saving information about particles for future use (previous positions, for instance).</p>

<!--more-->


<p>All fixes are derived from class Fix and must have constructor with the signature:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="n">FixMine</span><span class="p">(</span><span class="k">class</span> <span class="nc">LAMMPS</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Every fix must be registered in LAMMPS by writing the following lines of code in the header before include guards:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="cp">#ifdef FIX_CLASS</span>
</span><span class='line'><span class="n">FixStyle</span><span class="p">(</span><span class="n">name_of_your_fix_in_script</span><span class="p">,</span><span class="n">name_of_your_fix_class</span><span class="p">)</span>
</span><span class='line'><span class="cp">#else</span>
</span></code></pre></td></tr></table></div></figure>


<p>This code allows LAMMPS to find your fix when it parses input script. In addition, your fix header must be included in the file ”style_fix.h”. In case if you use LAMMPS’ make, this file is generated automatically - all files starting with fix_ are included, so call your header the same way. Otherwise, don’t forget to add your include into ”style_fix.h”.</p>

<p>Let’s write a simple fix which will print average velocity at the end of each timestep. First of all, implement a constructor:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="n">FixPrint2</span><span class="o">::</span><span class="n">FixPrint2</span><span class="p">(</span><span class="n">LAMMPS</span> <span class="o">*</span><span class="n">lmp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">narg</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">arg</span><span class="p">)</span>
</span><span class='line'><span class="o">:</span> <span class="n">Fix</span><span class="p">(</span><span class="n">lmp</span><span class="p">,</span> <span class="n">narg</span><span class="p">,</span> <span class="n">arg</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">narg</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="n">error</span><span class="o">-&gt;</span><span class="n">all</span><span class="p">(</span><span class="n">FLERR</span><span class="p">,</span><span class="s">&quot;Illegal fix print command&quot;</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">nevery</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">arg</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">nevery</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="n">error</span><span class="o">-&gt;</span><span class="n">all</span><span class="p">(</span><span class="n">FLERR</span><span class="p">,</span><span class="s">&quot;Illegal fix print command&quot;</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>
In the constructor you may parse your fix arguments. All fixes have pretty the same syntax:
fix &lt;fix_identifier> &lt;group_name> &lt;fix_name> &lt;fix_arguments></p>

<p>The first 3 parameters are parsed by LAMMPS, while <fix_arguments> should be parsed by user. In our case, we need to specify how often we want to print average velocity. For instance, once in 50 timesteps:
fix 1 print2 50</p>

<p>There is a special variable in Fix class called nevery which specify how often method end_of_step will be called. Thus all we need to do is just set it up.</p>

<p>The next method you need to implement is setmask:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="kt">int</span> <span class="n">FixPrint2</span><span class="o">::</span><span class="n">setmask</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>  <span class="n">mask</span> <span class="o">|=</span> <span class="n">FixConst</span><span class="o">::</span><span class="n">END_OF_STEP</span><span class="p">;</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">mask</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>
Here user must specify which methods of your fix should be called during execution. For instance, END_OF_STEP corresponds to the end_of_step method. There are 8 most important methods:</p>

<p>initial_integrate
post_integrate
pre_exchange
pre_neighbor
pre_force
post_force
final_integrate
end_of_step</p>

<p>These methods are called in predefined order during the execution of verlet algorithm (look at the method void Verlet::run(int n) in verlet.cpp). I listed them in this order. User must understand when he want to execute his code.</p>

<p>In case if we want to write print2 fix, we need only end_of_step.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="kt">void</span> <span class="n">FixPrint2</span><span class="o">::</span><span class="n">end_of_step</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="kt">double</span><span class="o">**</span> <span class="n">v</span> <span class="o">=</span> <span class="n">atom</span><span class="o">-&gt;</span><span class="n">v</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">nlocal</span> <span class="o">=</span> <span class="n">atom</span><span class="o">-&gt;</span><span class="n">nlocal</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">double</span> <span class="n">averageVelocity</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
</span><span class='line'>  <span class="n">memset</span><span class="p">(</span><span class="n">averageVelocity</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="p">));</span>
</span><span class='line'>  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">indexOfParticle</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">indexOfParticle</span> <span class="o">&lt;</span> <span class="n">nlocal</span><span class="p">;</span> <span class="o">++</span><span class="n">indexOfParticle</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">MathExtra</span><span class="o">::</span><span class="n">add3</span><span class="p">(</span><span class="n">averageVelocity</span><span class="p">,</span> <span class="n">v</span><span class="p">[</span><span class="n">indexOfParticle</span><span class="p">],</span> <span class="n">averageVelocity</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="n">MathExtra</span><span class="o">::</span><span class="n">scale3</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">nlocal</span><span class="p">,</span> <span class="n">averageVelocity</span><span class="p">);</span>
</span><span class='line'>  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">averageVelocity</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="err">“</span><span class="p">,</span> <span class="err">”</span>
</span><span class='line'>    <span class="o">&lt;&lt;</span> <span class="n">averageVelocity</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="err">“</span><span class="p">,</span> <span class="err">“</span>
</span><span class='line'>    <span class="o">&lt;&lt;</span> <span class="n">averageVelocity</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>
In order to use MathExtra routines, include math_extra.h. This file contains math functions to work with arrays of doubles as with math vectors.</p>

<p>In this code we use atom. This object is stored in the instance of Pointers class (see pointers.h). This object contains all global information about simulation system. Normally, such behaviour is achieved using Singleton design pattern but here it is implemented using using protected inheritance.</p>

<p>The code above computes average velocity for all particles in simulation. Yet you have one unused parameter in fix call from the script - &lt;group_name>. This parameter specifies the group of atoms used in the fix. So we should compute average for all particles in the simulation if  group_name == all, but it can be any group. In order to use this group information, use groupbit which is defined in class Fix:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">indexOfParticle</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">indexOfParticle</span> <span class="o">&lt;</span> <span class="n">nlocal</span><span class="p">;</span> <span class="o">++</span><span class="n">indexOfParticle</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">atom</span><span class="o">-&gt;</span><span class="n">mask</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">groupbit</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="c1">//Do all job here</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>The class Pointers contains instance of class Atom. Class atom encapsulates atoms positions, velocities, forces, etc. User can access them using particle index. Note, that particle indexes are changing every timestep because of sorting. So if you just stored position of atom from previous time step in your fix, it will not be valid on the next iteration. In order to handle this situation there are several methods which can be implemented:</p>

<p>  double memory_usage - return how much memory fix uses <br>
  void grow_arrays(int) - do reallocation of the per particle arrays in your fix <br>
  void copy_arrays(int i, int j) - copy i-th per-particle information to j-th. Used when atoms sorting is performed <br>
  void set_arrays(int i) - sets i-th particle related information to zero  <br></p>

<p>Note, that if your class implements these methods, it must call add calls of add_callback and delete_callback to constructor and destructor:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="n">FixSavePos</span><span class="o">::</span><span class="n">FixSavePos</span><span class="p">(</span><span class="n">LAMMPS</span> <span class="o">*</span><span class="n">lmp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">narg</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">arg</span><span class="p">)</span>  <span class="p">{</span>
</span><span class='line'>  <span class="c1">//...</span>
</span><span class='line'>  <span class="n">atom</span><span class="o">-&gt;</span><span class="n">add_callback</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">FixSavePos</span><span class="o">::~</span><span class="n">FixSavePos</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">atom</span><span class="o">-&gt;</span><span class="n">delete_callback</span><span class="p">(</span><span class="n">id</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>For instance, assume you need to write a fix which will store positions of atoms from previous timestep. You will add double** x to the header file. Than add allocation code to constructor:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="n">memory</span><span class="o">-&gt;</span><span class="n">create</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">x</span><span class="p">,</span> <span class="n">atom</span><span class="o">-&gt;</span><span class="n">nmax</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="s">&quot;FixSavePos:x&quot;</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>Free memory at destructor:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="n">memory</span><span class="o">-&gt;</span><span class="n">destroy</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>Finally, implement mentioned methods:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="kt">double</span> <span class="n">FixSavePos</span><span class="o">::</span><span class="n">memory_usage</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">nmax</span> <span class="o">=</span> <span class="n">atom</span><span class="o">-&gt;</span><span class="n">nmax</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">double</span> <span class="n">bytes</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">x</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>    <span class="n">bytes</span> <span class="o">+=</span> <span class="n">nmax</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="p">);</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">bytes</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span> <span class="n">FixSavePos</span><span class="o">::</span><span class="n">grow_arrays</span><span class="p">(</span><span class="kt">int</span> <span class="n">nmax</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">x</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>    <span class="n">memory</span><span class="o">-&gt;</span><span class="n">grow</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">x</span><span class="p">,</span> <span class="n">nmax</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="s">&quot;FixSavePos:x&quot;</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span> <span class="n">FixSavePos</span><span class="o">::</span><span class="n">copy_arrays</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">j</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">x</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>    <span class="n">memcpy</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">x</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="p">)</span> <span class="o">*</span> <span class="mi">3</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span> <span class="n">FixSavePos</span><span class="o">::</span><span class="n">set_arrays</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">x</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>    <span class="n">memset</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="p">)</span> <span class="o">*</span> <span class="mi">3</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Now, a little bit about memory allocation: I used LAMMPS memory class which is just a bunch of template functions for allocating 1D and 2D arrays. So you need to add include &#8220;memory.h&#8221; to have access to them.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java Modeling Language]]></title>
    <link href="http://KirillLykov.github.com/blog/2012/10/12/initial-post/"/>
    <updated>2012-10-12T16:40:00+02:00</updated>
    <id>http://KirillLykov.github.com/blog/2012/10/12/initial-post</id>
    <content type="html"><![CDATA[<p>Java Modeling Language is a Design by Contract(DBC) specification language for Java programs. DBC is a programming methodology,
which was introduced by B. Meyer and implemented in Eiffel programming language. The idea is pretty simple – a program component must do exactly
what is described in the contract. Hence, a user of the component may learn about it using the contract, the implementation of the component
might be different by must follow the contract. In Object Oriented languages a component is a class and a contract regulates the state of an object as well as behavior.
Using JML a programmer may specify the contract for methods and attributes. It is written as a comment in the class and
translated by the JML compiler into the Java code.</p>

<!--more-->


<p>Lets have a look at the example:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">class</span> <span class="nc">Building</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>  <span class="kt">int</span> <span class="n">floorsNumber</span><span class="o">;</span>
</span><span class='line'>  <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">MAX_FLOOR</span> <span class="o">=</span> <span class="mi">300</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">//@ invariant getFloorsNumber() &gt;= 0 &amp;&amp; </span>
</span><span class='line'>  <span class="c1">//@    getFloorsNumber() &lt; MAX_FLOOR;</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">//@ requires newFloors &lt; MAX_FLOOR;</span>
</span><span class='line'>  <span class="c1">//@ ensures getFloorNumber () &lt; MAX_FLOOR;</span>
</span><span class='line'>  <span class="kt">void</span> <span class="nf">addNewFloors</span><span class="o">(</span><span class="kt">int</span> <span class="n">newFloors</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>  <span class="n">floorsNumber</span> <span class="o">+=</span> <span class="n">newFloors</span><span class="o">;</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">//@ pure</span>
</span><span class='line'>  <span class="kt">int</span> <span class="nf">getFloorNumber</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">floorsNumber</span><span class="o">;</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>In this example, Building’s contract for the state specifies that the number of floors must be non-negative and not exceed the specified limit.
The keyword invariant is used to specify a contract for the object state. Method addNewFloors has prerequrement (“requires” keyword) that newFloors
is less than the limit and postreqirement (“ensures” keyword) that floorsNumber is less than the limit. The keyword “pure”(near getFloorNumber)
tells to the JML translator that this method doesn’t have side effects and might be used in JML specifications.</p>

<p>As you may see the syntax of the JML specification is comprehensible and can be understood even without knowledge in the domain.
The JML code is kind of developed assertions ensures that some assumptions written as predicates are true.</p>

<p>The JML syntax is quite expressive so a programmer can write sophisticated predicates with loops, sums and other constructions.
For instance, the JML specification for the method sorting array may look like that:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="cm">/*@ ensures </span>
</span><span class='line'><span class="cm">(\forall int i; 0 &lt;= i &amp;&amp; i &lt; a.length-1;</span>
</span><span class='line'><span class="cm">a[i] &lt; a[i+1]);</span>
</span><span class='line'><span class="cm">@*/</span>
</span><span class='line'><span class="kt">byte</span><span class="o">[]</span> <span class="nf">sort</span><span class="o">(</span><span class="kt">byte</span><span class="o">[]</span> <span class="n">a</span><span class="o">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>If you are interested you may read about syntax of JML at the <a href="http://www.eecs.ucf.edu/~leavens/JML/papers.shtml">JML web site</a>.</p>

<p>Now I will write about technical problems with JML. There are several JML compilers available – JML 5.4, Esc, OpenJML. The problem is
that all of them are developed more as a proof of concept than really working application.  Hence, they are buggy and are not well supported.
The JML 5.4 is the most reliable one yet it works only with Java 1.4. The OpenJML should have substituted JML 5.4 but at the current
moment it is just a prototype. The sad thing about it is the development was stopped one year ago.
If you want to try JML5.4, download <a href="http://www2.icorsi.ch/mod/resource/view.php?id=54421">it</a>, add environment variable JML = &lt;path to JML>.
To compile your application:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">java</span> <span class="o">-</span><span class="n">cp</span> <span class="s">&quot;$JML/bin/jml-release.jar:$JML/specs:.&quot;</span> <span class="n">org</span><span class="o">.</span><span class="na">jmlspecs</span><span class="o">.</span><span class="na">jmlrac</span><span class="o">.</span><span class="na">Main</span> <span class="s">&quot;&lt;your *.java&gt;&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>To run it:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">java</span> <span class="o">-</span><span class="n">cp</span> <span class="s">&quot;${JML}/bin/jmlruntime.jar:.&quot;</span> <span class="n">$</span><span class="o">*</span>
</span></code></pre></td></tr></table></div></figure>


<p>I think, it could be a good master thesis to make a working application out of OpenJML. If you think that it is not scientific enough,
there are several PhD dissertations at leading CS universities dedicated to development of DbC compilers for various languages.
Most of these languages are never used in industry. At the same time JML is used by at least students studying verification and similar courses so this work would be, not doubt, useful.</p>
]]></content>
  </entry>
  
</feed>
